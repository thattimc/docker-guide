# Docker Compose

Finally, `docker-compose.yml` is where the magic happens. This file describes the services that comprise your app (a database and a web app), how to get each one’s Docker image (the database just runs on a pre-made PostgreSQL image, and the web app is built from the current directory), and the configuration needed to link them together and expose the web app’s port.

Let create `docker-compose.yml` in the project root folder:

```yaml
version: '3'
services:
  db:
    image: postgres
    volumes:
      - ./tmp/db:/var/lib/postgresql/data
  web:
    build: .
    command: bash -c "rm -f tmp/pids/server.pid && bundle exec rails s -p 3000 -b '0.0.0.0'"
    volumes:
      - .:/usr/src/app
    ports:
      - "3000:3000"
    depends_on:
      - db
```

## Build the project

With those files in place, you can now generate the Rails skeleton app using `docker-compose run`:

```bash
docker-compose run web rails new . --force --no-deps --database=postgresql
```

First, Compose builds the image for the `web` service using the `Dockerfile`. Then it runs `rails new` inside a new container, using that image. Once it’s done, you should have generated a new app.

List the files.

```bash
total 96
drwxr-xr-x  25 tim  staff   800 Aug 26 14:38 .
drwx------@  5 tim  staff   160 Aug 26 14:38 ..
drwxr-xr-x  10 tim  staff   320 Aug 26 16:10 .git
-rw-r--r--   1 tim  staff   590 Aug 26 14:37 .gitignore
-rw-r--r--   1 tim  staff    11 Aug 26 14:37 .ruby-version
-rw-r--r--   1 tim  staff   462 Aug 26 11:02 Dockerfile
-rw-r--r--   1 tim  staff  1971 Aug 26 14:37 Gemfile
-rw-r--r--   1 tim  staff  5535 Aug 26 14:38 Gemfile.lock
-rw-r--r--   1 tim  staff   374 Aug 26 14:37 README.md
-rw-r--r--   1 tim  staff   227 Aug 26 14:37 Rakefile
drwxr-xr-x  11 tim  staff   352 Aug 26 14:37 app
drwxr-xr-x   8 tim  staff   256 Aug 26 14:38 bin
drwxr-xr-x  16 tim  staff   512 Aug 26 14:37 config
-rw-r--r--   1 tim  staff   130 Aug 26 14:37 config.ru
drwxr-xr-x   3 tim  staff    96 Aug 26 14:37 db
-rw-r--r--   1 tim  staff   311 Aug 26 14:35 docker-compose.yml
-rwxr-xr-x   1 tim  staff   208 Aug 26 11:18 entrypoint.sh
drwxr-xr-x   4 tim  staff   128 Aug 26 14:37 lib
drwxr-xr-x   3 tim  staff    96 Aug 26 14:37 log
-rw-r--r--   1 tim  staff   233 Aug 26 14:37 package.json
drwxr-xr-x   9 tim  staff   288 Aug 26 14:37 public
drwxr-xr-x   3 tim  staff    96 Aug 26 14:37 storage
drwxr-xr-x  12 tim  staff   384 Aug 26 14:37 test
drwxr-xr-x   6 tim  staff   192 Aug 26 14:37 tmp
drwxr-xr-x   3 tim  staff    96 Aug 26 14:37 vendor
```

Install the webpacker by running:

```bash
rails webpacker:install
```

If you are running Docker on Linux, the files `rails new` created are owned by root. This happens because the container runs as the root user. If this is the case, change the ownership of the new files.

```bash
sudo chown -R $USER:$USER .
```

If you are running Docker on Mac or Windows, you should already have ownership of all files, including those generated by `rails new`.

Now that you’ve got a new `Gemfile`, you need to build the image again. (This, and changes to the Gemfile or the Dockerfile, should be the only times you’ll need to rebuild.)

```bash
docker-compose build
```

## Connect the database

The app is now bootable, but you’re not quite there yet. By default, Rails expects a database to be running on `localhost` - so you need to point it at the `db` container instead. You also need to change the database and username to align with the defaults set by the `postgres` image.

Replace the contents of `config/database.yml` with the following:

```yaml
default: &default
  adapter: postgresql
  encoding: unicode
  host: db
  username: postgres
  password:
  pool: 5

development:
  <<: *default
  database: myapp_development


test:
  <<: *default
  database: myapp_test
```

You can now boot the app with `docker-compose up`:

```bash
docker-compose up
```

If all’s well, you should see some PostgreSQL output.

```
Starting myapp_db_1 ... done
Recreating myapp_web_1 ... done
Attaching to myapp_db_1, myapp_web_1
db_1   | 2019-08-26 10:05:39.266 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
db_1   | 2019-08-26 10:05:39.267 UTC [1] LOG:  listening on IPv6 address "::", port 5432
db_1   | 2019-08-26 10:05:39.273 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
db_1   | 2019-08-26 10:05:39.364 UTC [23] LOG:  database system was shut down at 2019-08-26 10:03:20 UTC
db_1   | 2019-08-26 10:05:39.404 UTC [1] LOG:  database system is ready to accept connections
```

Finally, you need to create the database. In another terminal, run:

```bash
docker-compose run web rake db:create
```

Here is an example of the output from that command:

```
Starting myapp_db_1 ... done
Created database 'myapp_development'
Created database 'myapp_test'
```

## View the Rails welcome page!

That’s it. Your app should now be running on port 3000 on your Docker daemon.

On Docker Desktop for Mac and Docker Desktop for Windows, go to `http://localhost:3000` on a web browser to see the Rails Welcome.

If you are using Docker Machine, then `docker-machine ip MACHINE_VM` returns the Docker host IP address, to which you can append the port (`<Docker-Host-IP>:3000`).

## Stop the application

To stop the application, run `docker-compose down` in your project directory. You can use the same terminal window in which you started the database, or another one where you have access to a command prompt. This is a clean way to stop the application.

## Restart the application

To restart the application run `docker-compose up` in the project directory.

## Rebuild the application

If you make changes to the Gemfile or the Compose file to try out some different configurations, you need to rebuild. Some changes require only `docker-compose up --build`, but a full rebuild requires a re-run of `docker-compose run web bundle install` to sync changes in the `Gemfile.lock` to the host, followed by `docker-compose up --build`.

Here is an example of the first case, where a full rebuild is not necessary. Suppose you simply want to change the exposed port on the local host from `3000` in our first example to `3001`. Make the change to the Compose file to expose port 3000 on the container through a new port, `3001`, on the host, and save the changes:

```yaml
ports: - "3001:3000"
```

Now, rebuild and restart the app with `docker-compose up --build`.

Inside the container, your app is running on the same port as before `3000`, but the Rails Welcome is now available on `http://localhost:3001` on your local host.

Next: [Share Your Image](09-share-your-image.md)